<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SUNMIRROR</title>
  <link rel="stylesheet" href="assets/fontawesome/fontawesome-minimal.css">
  <style>
  body {
    font-family: system-ui,-apple-system,BlinkMacSystemFont,sans-serif;
    margin: 0;
    display: flex;
    min-height: 100vh;
    background: #f5f5f7;
    overflow-x: hidden;
  }
  
  @media (max-width: 768px) {
    body {
      flex-direction: column;
    }
  }
  #app {
    flex: 1;
    display: flex;
    padding: 1rem;
    gap: 1rem;
    position: relative;
    flex-direction: column;
  }
  
  @media (min-width: 769px) {
    #app {
      flex-direction: row;
    }
  }
  
  /* Mobile-specific layout */
  @media (max-width: 768px) {
    #app {
      padding: 0.5rem;
      gap: 0.5rem;
      margin-bottom: 150px; /* Space for timeline */
    }
  }
  .panel {
    width: 100%;
    padding: 1rem;
    background: white;
    border-radius: 12px;
    box-shadow: 0 20px 40px -10px rgba(0,0,0,0.1);
    display: flex;
    flex-direction: column;
    gap: 12px;
    order: 1;
    max-height: calc(100vh - 14rem);
    overflow-y: auto;
  }
  
  @media (min-width: 769px) {
    .panel {
      width: 330px;
      max-width: 330px;
      order: 0;
    }
  }
  
  /* Mobile-specific panel layout */
  @media (max-width: 768px) {
    .panel {
      padding: 10px;
      border-radius: 8px;
      gap: 8px;
    }
  }
  h1 {
    font-size: 1.1rem;
    margin: 0 0 8px;
  }
  #svg-container {
    flex: 1;
    position: relative;
    overflow: visible;
    min-height: 300px;
    display: flex;
    justify-content: center;
    align-items: center;
    order: 0;
    transform: scaleX(-1);
  }
  
  @media (min-width: 769px) {
    #svg-container {
      order: 1;
    }
  }
  
  /* Mobile-specific SVG container */
  @media (max-width: 768px) {
    #svg-container {
      min-height: auto;
      height: 60vh;
      overflow: hidden;
      margin-bottom: 0;
    }
  }
  svg {
    max-width: 100%;
    max-height: 70vh;
    height: auto;
    display: block;
    cursor: pointer;
    user-select: none;
  }
  
  /* Mobile-specific SVG sizing */
  @media (max-width: 768px) {
    svg {
      max-height: 100%;
      width: 100%;
      height: 100%;
    }
  }
  polygon.triangle {
    stroke: #222;
    stroke-width: 1;
    fill: transparent;
    transition: fill .2s, stroke .2s, fill-opacity .2s;
  }
  
  .angle-text {
    font-size: 10px;
    fill: #333;
    text-anchor: middle;
    dominant-baseline: middle;
    font-weight: bold;
    pointer-events: none;
  }
  
  /* Triangle fill colors based on angle */
  polygon.triangle.angle-below-90 {
    fill: #555 !important;
    fill-opacity: 0.3;
  }
  
  polygon.triangle.angle-90 {
    fill-opacity: 0.5;
  }
  
  polygon.triangle.angle-above-90 {
    fill: #bd2727 !important;
    fill-opacity: 0.3;
  }
  polygon.triangle:hover, polygon.triangle.hover-highlight {
    stroke-width: 3;
    stroke: #2563eb;
  }
  polygon.triangle.selected {
    fill: #ff9800;
    stroke: #ff5722;
    stroke-width: 1;
    fill-opacity: 0.3;
  }
  
  .triangle.checked {
    stroke: #0d47a1 !important;
    stroke-width: 2 !important;
  }
  .controls {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }
  
  .save-container {
    display: flex;
    align-items: center;
    gap: 0;
    margin-left: auto;
  }
  
  #save-filename {
    padding: 4px 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 0.9rem;
    width: 130px;
  }
  
  #play-on-mirrors {
    background-color: #10b981;
  }
  
  #play-on-mirrors:hover {
    background-color: #059669;
  }
  button {
    background: #2563eb;
    color: white;
    border: none;
    padding: 8px 12px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 0.9rem;
    touch-action: manipulation;
  }
  
  @media (max-width: 480px) {
    button {
      padding: 10px 14px;
      font-size: 1rem;
      flex: 1;
      min-width: fit-content;
    }
  }
  button.secondary {
    background: #f3f4f6;
    color: #374151;
  }
  
  button.primary {
    background: #4CAF50;
    color: white;
  }
  .selected-list {
    flex: 1;
    overflow: auto;
    background: #f9fafb;
    padding: 8px;
    border-radius: 6px;
    font-size: 0.85rem;
    line-height: 1.3;
  }
  
  .triangle-item {
    margin-bottom: 1px;
    padding: 0px;
    background: #fff;
    border-radius: 4px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    cursor: pointer;
    transition: background-color 0.2s, box-shadow 0.2s;
  }
  
  .triangle-item:hover, .triangle-item.hover-highlight {
    background: #f0f9ff;
    box-shadow: 0 2px 6px rgba(37, 99, 235, 0.2);
  }
  
  .triangle-header {
    display: flex;
    align-items: center;
    margin-bottom: 5px;
    font-weight: 500;
  }
  
  .triangle-header span:nth-child(2) {
    flex: 1;
    margin-left: 5px;
  }
  
  .triangle-header span:last-child {
    margin-left: auto;
  }
  
  /* Checkbox styles */
  .checkbox-container {
    display: inline-block;
    position: relative;
    cursor: pointer;
    user-select: none;
    width: 18px;
    height: 18px;
  }
  
  .checkbox-container input {
    position: absolute;
    opacity: 0;
    cursor: pointer;
    height: 0;
    width: 0;
  }
  
  .checkmark {
    position: absolute;
    top: 0;
    left: 0;
    height: 18px;
    width: 18px;
    background-color: #eee;
    border-radius: 3px;
    border: 1px solid #ccc;
  }
  
  .checkbox-container:hover input ~ .checkmark {
    background-color: #ddd;
  }
  
  .checkbox-container input:checked ~ .checkmark {
    background-color: #2563eb;
    border-color: #2563eb;
  }
  
  .checkmark:after {
    content: "";
    position: absolute;
    display: none;
  }
  
  .checkbox-container input:checked ~ .checkmark:after {
    display: block;
  }
  
  .checkbox-container .checkmark:after {
    left: 6px;
    top: 2px;
    width: 4px;
    height: 9px;
    border: solid white;
    border-width: 0 2px 2px 0;
    transform: rotate(45deg);
  }
  
  .triangle-angle-control {
    padding: 0 2px;
  }
  
  .group-checkbox-container {
    display: flex;
    align-items: center;
    margin: 10px 0;
    padding: 8px;
    background-color: #f5f5f5;
    border-radius: 4px;
    border-left: 3px solid #2563eb;
  }
  
  .group-checkbox-container span {
    margin-left: 8px;
    font-weight: 500;
  }
  
  .individual-angle-slider {
    width: 100%;
    margin: 5px 0;
  }
  
  .angle-controls {
    margin: 10px 0;
    padding: 10px;
    background: #f0f4f8;
    border-radius: 6px;
  }
  
  .angle-buttons-group {
    display: flex;
    align-items: center;
    gap: 10px;
    margin: 8px 0;
    justify-content: space-between;
  }
  
  .angle-input-group {
    display: flex;
    align-items: center;
  }
  
  .angle-input {
    width: 40px;
    text-align: right;
    border: 1px solid #ccc;
    border-radius: 4px 0 0 4px;
    padding: 5px;
    margin: 0;
  }
  
  .angle-input-group .angle-btn {
    width: 45px;
    border-radius: 0 4px 4px 0;
    margin: 0;
  }
  
  .angle-btn {
    flex: 1;
    padding: 6px 0;
    background-color: #f0f4f8;
    color: #333;
    border: 1px solid #ccc;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s, transform 0.1s;
  }
  
  .angle-btn:hover {
    background-color: #e0e7ef;
  }
  
  .angle-btn:active {
    transform: scale(0.98);
  }
  
  .angle-btn.active {
    background-color: #2563eb;
    color: white;
    border-color: #1e40af;
  }
  
  /* Hide selected list on mobile */
  @media (max-width: 768px) {
    .selected-list {
      display: none;
    }
  }
  .triangle-info {
    font-size: 0.8rem;
    color: #555;
  }
  
  /* Mobile triangle info layout */
  @media (max-width: 768px) {
    .triangle-info {
      display: inline-block;
      margin-right: 12px;
    }
  }
  .badge {
    display: inline-block;
    background: #2563eb;
    color: white;
    padding: 2px 6px;
    border-radius: 999px;
    font-size: 0.65rem;
    vertical-align: middle;
    margin-left: 4px;
  }
  .footer {
    margin-top: auto;
    font-size: 0.65rem;
    color: #666;
  }
  #timeline-container {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: white;
    box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
    padding: 12px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    z-index: 100;
  }
  
  @media (max-width: 768px) {
    #timeline-container {
      padding: 8px;
      gap: 6px;
    }
  }
  .timeline-controls {
    display: flex;
    gap: 8px;
    align-items: center;
    flex-wrap: wrap;
  }
  .timeline-info {
    margin-left: auto;
    font-size: 0.85rem;
    display: flex;
    align-items: center;
    gap: 5px;
    flex-wrap: wrap;
  }
  
  @media (max-width: 480px) {
    .timeline-info {
      width: 100%;
      margin-left: 0;
      margin-top: 8px;
    }
  }
  #frames-container {
    display: flex;
    gap: 8px;
    overflow-x: auto;
    padding: 5px 0;
    min-height: 60px;
    scrollbar-width: thin;
    scrollbar-color: #c1c1c1 #f1f1f1;
    -webkit-overflow-scrolling: touch;
    position: relative;
  }
  
  #frames-container::-webkit-scrollbar {
    height: 8px;
  }
  
  #frames-container::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 10px;
  }
  
  #frames-container::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 10px;
  }
  
  #frames-container::-webkit-scrollbar-thumb:hover {
    background: #a1a1a1;
  }
  .frame {
    min-width: 50px;
    height: 50px;
    border: 2px solid #ccc;
    border-radius: 6px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    background: #f0f0f0;
    position: relative;
    flex-shrink: 0;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
  }
  .frame.active {
    border-color: #2563eb;
    background: #e0e7ff;
  }
  .frame-number {
    font-weight: bold;
    font-size: 0.9rem;
  }
  .hidden {
    display: none;
  }
</style>
</head>
<body>
  <div id="app">
    <button id="fullscreen-btn" style="position: absolute; top: 10px; right: 10px; z-index: 1000; background: #2563eb; color: white; border: none; border-radius: 4px; padding: 5px 10px; cursor: pointer;">
      <i class="fas fa-expand"></i> Fullscreen
    </button>
    <button id="shutdown-raspberry" style="position: absolute; top: 50px; right: 10px; z-index: 1000; background: #6b21a8; color: white; border: none; border-radius: 4px; padding: 5px 10px; cursor: pointer;">
      <i class="fas fa-power-off"></i> Shutdown
    </button>
    <div class="panel">
      <div class="controls">
        <button id="select-all">Select All</button>
        <button id="clear" class="secondary">Clear</button>
        <div class="save-container">
          <input type="text" id="save-filename" placeholder="filename" value="triangle_frames" style="margin-right: 2px;">
          <div style="display: flex; flex-direction: column; align-items: center; margin: 0;">
            <label for="loop-checkbox" style="font-size: 0.7rem; margin-bottom: 1px;">Loop</label>
            <input type="checkbox" id="loop-checkbox" style="margin: 0;">
          </div>
          <button id="play-on-mirrors" title="Play on mirrors" style="margin: 0; border-radius: 4px 0 0 4px;"><i class="fas fa-play-circle"></i></button>
          <button id="stop-mirrors" title="Stop animation on mirrors" style="background:red;margin: 0; border-radius: 0;"><i class="fas fa-stop"></i></button>
          <button id="save" title="Save animation" style="margin: 0; border-radius: 0;"><i class="fas fa-save"></i></button>
          <button id="import" title="Import animation" style="margin: 0; border-radius: 0 4px 4px 0;"><i class="fas fa-file-import"></i></button>
          <input type="file" id="import-file" accept=".json" style="display: none;">
        </div>
      </div>
      <div class="triangle-info">Selected: <span id="selected-count">0</span></div>
      <div class="triangle-info">Current frame: <span id="current-frame">1</span></div>
      
      <!-- Angle controls -->
      <div class="angle-controls">
        <label>Triangle angle:</label>
        <div class="angle-buttons-group">
          <div class="angle-input-group">
            <input type="number" id="custom-angle-1" min="60" max="130" value="60" class="angle-input">
            <button id="angle-20" class="angle-btn">°</button>
          </div>
          <button id="angle-90" class="angle-btn">90°</button>
          <div class="angle-input-group">
            <input type="number" id="custom-angle-2" min="60" max="130" value="130" class="angle-input">
            <button id="angle-160" class="angle-btn">°</button>
          </div>
        </div>
        <button id="reset-angles" hidden class="secondary">Reset to 90°</button>
      </div>
      
      <!-- Group checkbox for selecting/deselecting all triangles -->
      <div class="group-checkbox-container">
        <label class="checkbox-container">
          <input type="checkbox" id="group-checkbox" checked>
          <span class="checkmark" style="left: -5px;"></span>
        </label>
        <span>Select/deselect all triangles</span>
      </div>
      
      <div class="selected-list" id="selected-list">None</div>
      <div class="footer">
        Click individual triangles to toggle. Hold Ctrl to select multiple triangles. Selected ones are highlighted.
      </div>
    </div>
    <div id="svg-container">
      <svg id="hex-svg" viewBox="-220 -220 440 440" aria-label="Rotated hexagon subdivided into selectable equilateral triangles" role="img">
        <!-- Group with rotation -->
        <g id="rotated-group" transform="rotate(210)">
          <!-- Triangles and hexagon boundary injected here -->
        </g>
      </svg>
    </div>
    <div id="timeline-container">
      <div class="timeline-controls">
        <button id="add-frame" title="Add frame"><i class="fas fa-plus"></i> Frame</button>
        <button id="delete-frame" title="Delete frame"><i class="fas fa-trash"></i> Frame</button>
        <button id="play-animation" title="Play animation"><i class="fas fa-play"></i></button>
        <button id="stop-animation" class="hidden" title="Stop animation"><i class="fas fa-stop"></i></button>
        <span class="timeline-info">
          <label for="animation-speed">Animation Speed:</label> 
          <select id="animation-speed">
            <option value="2000">Slow</option>
            <option value="1000" selected>Normal</option>
            <option value="500">Fast</option>
          </select>
        </span>
      </div>
      <div id="frames-container">
        <!-- Frames will be added here -->
        <div class="frame active" data-frame="0">
          <div class="frame-number">1</div>
        </div>
      </div>
    </div>
  </div>



<script>
(function(){

  // Fullscreen button functionality
  const fullscreenBtn = document.getElementById('fullscreen-btn');
  
  fullscreenBtn.addEventListener('click', () => {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().catch(err => {
        console.error(`Error attempting to enable fullscreen: ${err.message}`);
      });
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      }
    }
  });
  
  // Get reference to shutdown button
  const shutdownRaspberryBtn = document.getElementById('shutdown-raspberry');
  
  // Update buttons based on fullscreen state
  document.addEventListener('fullscreenchange', () => {
    if (document.fullscreenElement) {
      fullscreenBtn.innerHTML = '<i class="fas fa-compress"></i> Exit Fullscreen';
      // Hide shutdown button in fullscreen mode
      shutdownRaspberryBtn.style.display = 'none';
    } else {
      fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i> Fullscreen';
      // Show shutdown button when not in fullscreen mode
      shutdownRaspberryBtn.style.display = 'block';
    }
  });

  // Parameters
  const smallSide = 1; // unit triangle side
  const hexSide = 3; // hexagon side in same units
  const scale = 60; // scale to pixels
  const h = Math.sqrt(3)/2 * smallSide; // height in units
  const hexRadius = hexSide; // for regular hexagon, side == radius
  // Build hexagon vertices (unit)
  const hexVertices = [];
  for (let k=0;k<6;k++){
    const ang = k * Math.PI / 3;
    hexVertices.push([hexRadius * Math.cos(ang), hexRadius * Math.sin(ang)]);
  }

  // Point in polygon (ray-casting)
  function pointInPoly(x, y, poly){
    let inside = false;
    for (let i=0, j=poly.length-1; i<poly.length; j=i++){
      const xi = poly[i][0], yi = poly[i][1];
      const xj = poly[j][0], yj = poly[j][1];
      const intersect = ((yi > y) !== (yj > y)) &&
        (x < (xj - xi)*(y - yi)/(yj - yi) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  // Generate raw triangles with centroids
  let raw = [];
  const jMin = -Math.ceil((hexRadius+h)/h), jMax = Math.ceil((hexRadius+h)/h);
  for(let j=jMin;j<=jMax;j++){
    const y = j*h, xOffset = 0.5*(j%2);
    const iMin = -Math.ceil(hexRadius+2), iMax = Math.ceil(hexRadius+2);
    for(let i=iMin;i<=iMax;i++){
      const x = i + xOffset;
      // upward
      const A=[x,y], B=[x+smallSide,y], C=[x+0.5*smallSide,y+h];
      const cu=[(A[0]+B[0]+C[0])/3, (A[1]+B[1]+C[1])/3];
      if(pointInPoly(cu[0],cu[1],hexVertices)) raw.push({pts:[A,B,C],cent:cu});
      // downward
      const D=[x,y], E=[x+smallSide,y], F=[x+0.5*smallSide,y-h];
      const cd=[(D[0]+E[0]+F[0])/3, (D[1]+E[1]+F[1])/3];
      if(pointInPoly(cd[0],cd[1],hexVertices)) raw.push({pts:[D,E,F],cent:cd});
    }
  }
  
  // Sort into rings by distance then angle, with offset for rings 2 & 3
  raw.sort((a,b)=> Math.hypot(a.cent[0],a.cent[1]) - Math.hypot(b.cent[0],b.cent[1]));
  const ringSizes=[6,18,30]; // Known sizes of each ring
  let idx=0;
  const triangles=[]; // Final ordered triangles
  
  ringSizes.forEach((size,ri)=>{
    const group = raw.slice(idx, idx+size);
    // compute custom angle (start at top-right)
    group.forEach(t=>{
      const [x,y]=t.cent;
      const angStd = Math.atan2(y,x)*180/Math.PI;
      const angCustom = (90 - angStd + 360)%360;
      t.orderAng = (angCustom - 45 + 360)%360;
    });
    group.sort((a,b)=>a.orderAng - b.orderAng);
    // for rings 2 & 3, start one step behind (rotate by one)
    if(ri>0) group.unshift(group.pop());
    
    // Add triangle points to final array
    group.forEach(t => triangles.push(t.pts));
    idx += size;
  });

  // UI elements
  const svg = document.getElementById("hex-svg");
  const group = document.getElementById("rotated-group");
  const totalCountEl = document.getElementById("total-count");
  const selectedCountEl = document.getElementById("selected-count");
  const currentFrameEl = document.getElementById("current-frame");
  const selectedListEl = document.getElementById("selected-list");
  const addFrameBtn = document.getElementById("add-frame");
  const deleteFrameBtn = document.getElementById("delete-frame");
  const framesContainer = document.getElementById("frames-container");
  const playBtn = document.getElementById("play-animation");
  const stopBtn = document.getElementById("stop-animation");
  const selectAllBtn = document.getElementById("select-all");
  const clearBtn = document.getElementById("clear");
  const saveBtn = document.getElementById("save");
  const animationSpeedSelect = document.getElementById("animation-speed");
  
  // Angle control elements
  const angleValue = document.getElementById("angle-value");
  const resetAnglesBtn = document.getElementById("reset-angles");
  
  // Animation state
  let currentFrameIndex = 0;
  let isPlaying = false;
  let animationInterval = null;
  
  // Initialize the first frame
  const frames = [
    { id: 0, selected: new Set(), angles: {} } // First frame with angles map
  ];
  
  // Function to prepare frames data for JSON export
  function prepareFramesForExport() {
    return frames.map((frame, index) => {
      // Create a complete angles object with default values for all triangles
      const completeAngles = {};
      
      // Fill in all triangles with default or set angles
      for (let i = 1; i <= triangles.length; i++) {
        completeAngles[i] = frame.angles[i] || 90;
      }
      
      return {
        id: index + 1,
        angles: completeAngles
      };
    });
  }
  
  // Function to update the selected count display
  function updateSelectedCount() {
    const currentFrame = frames[currentFrameIndex];
    selectedCountEl.textContent = currentFrame.selected.size;
  }
  
  // Function to update the frame display based on the current frame
  function updateFrameDisplay() {
    // Update current frame indicator
    document.getElementById('current-frame').textContent = currentFrameIndex + 1;
    
    // Update frame selection in the UI
    document.querySelectorAll('.frame').forEach((frame, index) => {
      if (index === currentFrameIndex) {
        frame.classList.add('active');
      } else {
        frame.classList.remove('active');
      }
    });
    
    // Update triangle selection based on the current frame
    const currentFrame = frames[currentFrameIndex];
    document.querySelectorAll('polygon.triangle').forEach(triangle => {
      const index = triangle.getAttribute('data-index');
      if (currentFrame.selected.has(index)) {
        triangle.classList.add('selected');
      } else {
        triangle.classList.remove('selected');
      }
    });
    
    // Update the selected count
    updateSelectedCount();
  }
  
  // Default angle values
  const DEFAULT_ANGLE = 90;
  const DEFAULT_ANGLE_1 = 60;
  const DEFAULT_ANGLE_2 = 130;
  const MIN_ANGLE = 60;
  const MAX_ANGLE = 130;
  
  // Track Ctrl key state and touch state
  let isCtrlPressed = false;
  let isTouchSelecting = false;
  
  // Initialize triangles
  // Add hexagon boundary for reference (optional)
  const hexPath = document.createElementNS("http://www.w3.org/2000/svg","polygon");
  hexPath.setAttribute("points", hexVertices.map(p => (p[0]*scale) + "," + (p[1]*scale)).join(" "));
  hexPath.setAttribute("fill","none");
  hexPath.setAttribute("stroke","#444");
  hexPath.setAttribute("stroke-width","2");
  hexPath.setAttribute("stroke-dasharray","6,4");
  group.appendChild(hexPath);

  // Create a function to render a triangle with an angle
  function renderTriangle(trianglePoints, index, angle = DEFAULT_ANGLE) {
    const poly = document.createElementNS("http://www.w3.org/2000/svg","polygon");
    
    // Scale the triangle points
    const scaled = trianglePoints.map(p => [(p[0]*scale).toFixed(3), (p[1]*scale).toFixed(3)]);
    poly.setAttribute("points", scaled.map(p=>p.join(",")).join(" "));
    
    // Set attributes
    poly.classList.add("triangle");
    poly.setAttribute("data-index", index); // 1-based
    poly.setAttribute("data-angle", angle); // Store angle as attribute
    poly.setAttribute("aria-label", "Triangle " + index);
    poly.setAttribute("role","button");
    
    // Calculate centroid (needed for potential future use)
    const centroid = [
      (parseFloat(scaled[0][0]) + parseFloat(scaled[1][0]) + parseFloat(scaled[2][0])) / 3,
      (parseFloat(scaled[0][1]) + parseFloat(scaled[1][1]) + parseFloat(scaled[2][1])) / 3
    ];
    
    // click handler for triangle
    poly.addEventListener("click", (e)=>{
      if (isPlaying) return; // Don't allow changes while playing
      
      const index = poly.getAttribute("data-index");
      const currentFrame = frames[currentFrameIndex];
      
      if (currentFrame.selected.has(index)){
        currentFrame.selected.delete(index);
        poly.classList.remove("selected");
        
        // Reset angle to 90 degrees when removed from selection
        currentFrame.angles[index] = DEFAULT_ANGLE;
        updateAngleIndicator(index, DEFAULT_ANGLE);
        
        // Update checkbox state
        checkboxStates[index] = false;
        poly.classList.remove("checked");
        
        // Update the checkbox in the UI if it exists
        const checkbox = document.querySelector(`.triangle-checkbox[data-triangle-id="${index}"]`);
        if (checkbox) {
          checkbox.checked = false;
        }
      } else {
        currentFrame.selected.add(index);
        poly.classList.add("selected");
        
        // Update checkbox state
        checkboxStates[index] = true;
        poly.classList.add("checked");
        
        // Update the checkbox in the UI if it exists
        const checkbox = document.querySelector(`.triangle-checkbox[data-triangle-id="${index}"]`);
        if (checkbox) {
          checkbox.checked = true;
        }
      }
      
      // Update angle input to show the angle of the last selected triangle
      const angle = currentFrame.angles[index] || DEFAULT_ANGLE;
      
      updateUI();
    });
    
    // Add hover events for triangle
    poly.addEventListener("mouseenter", (e) => {
      const index = poly.getAttribute("data-index");
      const sidebarItem = document.querySelector(`.triangle-item .triangle-angle-btn[data-triangle-id="${index}"]`)?.closest('.triangle-item');
      if (sidebarItem) {
        sidebarItem.classList.add("hover-highlight");
      }
      
      // Auto-select triangle when hovering with Ctrl key pressed
      if (isCtrlPressed && !isPlaying) {
        const currentFrame = frames[currentFrameIndex];
        
        if (!currentFrame.selected.has(index)) {
          currentFrame.selected.add(index);
          poly.classList.add("selected");

          
        }

        // Make sure the checkbox is checked when selected via Ctrl+hover
        checkboxStates[index] = true;
        updateUI();
      }
    });
    
    poly.addEventListener("mouseleave", (e) => {
      const index = poly.getAttribute("data-index");
      const sidebarItem = document.querySelector(`.triangle-item .triangle-angle-btn[data-triangle-id="${index}"]`)?.closest('.triangle-item');
      if (sidebarItem) {
        sidebarItem.classList.remove("hover-highlight");
      }
    });
    
    group.appendChild(poly);
    
    return { polygon: poly };
  }
  
  // Initialize triangles with default angles
  const triangleElements = [];
  triangles.forEach((tri, idx)=>{
    const index = idx + 1; // 1-based index
    const elements = renderTriangle(tri, index);
    triangleElements.push(elements);
  });
  
  // We'll add hover functionality directly after UI updates instead of using event delegation

  // Store checkbox states to preserve them during UI updates
  const checkboxStates = {};
  
  // Update UI to reflect current frame and selection
  function updateUI(){
    currentFrameEl.textContent = currentFrameIndex + 1;
    
    const currentFrame = frames[currentFrameIndex];
    selectedCountEl.textContent = currentFrame.selected.size;
    
    // Save current checkbox states before updating UI
    document.querySelectorAll('.triangle-checkbox').forEach(checkbox => {
      const id = checkbox.getAttribute('data-triangle-id');
      if (checkbox.checked) {
        checkboxStates[id] = true;
      }
    });
    
    // Update triangle colors based on checkbox states
    document.querySelectorAll('polygon.triangle').forEach(triangle => {
      const id = triangle.getAttribute('data-index');
      triangle.classList.remove('checked');
      if (checkboxStates[id]) {
        triangle.classList.add('checked');
      }
    });
    
    const arr = Array.from(currentFrame.selected).sort((a,b)=>+a - +b);
    if (arr.length === 0){
      selectedListEl.textContent = "None";
    } else {
      // Show triangle IDs and their angles with individual controls
      selectedListEl.innerHTML = arr.map(i => {
        const angle = currentFrame.angles[i] || DEFAULT_ANGLE;
        // Use stored checkbox state or default to checked if not found
        // When a triangle is in the selected list, it should be checked by default
        const isChecked = checkboxStates[i] !== undefined ? checkboxStates[i] : true;
        return `
          <div class="triangle-item" data-triangle-id="${i}">
            <div class="triangle-header">
              <label class="checkbox-container">
                <input type="checkbox" class="triangle-checkbox" data-triangle-id="${i}" ${isChecked ? 'checked' : ''}>
                <span class="checkmark"></span>
              </label>
              <span>Triangle <strong>#${i}</strong></span>
              <span class="angle-value">${angle}°</span>
            </div>
            <div class="triangle-angle-control">
              <div class="angle-buttons-group">
                <button class="angle-btn triangle-angle-btn ${angle === DEFAULT_ANGLE_1 ? 'active' : ''}" data-angle="${DEFAULT_ANGLE_1}" data-triangle-id="${i}">${DEFAULT_ANGLE_1}°</button>
                <button class="angle-btn triangle-angle-btn ${angle === 90 ? 'active' : ''}" data-angle="90" data-triangle-id="${i}">90°</button>
                <button class="angle-btn triangle-angle-btn ${angle === DEFAULT_ANGLE_2 ? 'active' : ''}" data-angle="${DEFAULT_ANGLE_2}" data-triangle-id="${i}">${DEFAULT_ANGLE_2}°</button>
              </div>
            </div>
          </div>
        `;
      }).join("");
      
      // Add event listeners to individual angle buttons
      document.querySelectorAll('.triangle-angle-btn').forEach(btn => {
        btn.addEventListener('click', function() {
          const triangleId = this.getAttribute('data-triangle-id');
          const newAngle = parseInt(this.getAttribute('data-angle'));
          
          // Update angle in data structure
          currentFrame.angles[triangleId] = newAngle;
          
          // Update angle indicator
          updateAngleIndicator(triangleId, newAngle);
          
          // Update the displayed angle value
          const angleDisplay = this.closest('.triangle-item').querySelector('.angle-value');
          angleDisplay.textContent = `${newAngle}°`;
          
          // Update active button state
          this.closest('.angle-buttons-group').querySelectorAll('.triangle-angle-btn').forEach(b => {
            b.classList.remove('active');
          });
          this.classList.add('active');
          
          // Uncheck the checkbox when angle is changed individually
          const checkbox = this.closest('.triangle-item').querySelector('.triangle-checkbox');
          if (checkbox) {
            checkbox.checked = false;
          }
        });
      });
      
      // Add event listeners to checkboxes
      document.querySelectorAll('.triangle-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', function() {
          const triangleId = this.getAttribute('data-triangle-id');
          checkboxStates[triangleId] = this.checked;
          
          // Update triangle color in the hexagon
          const svgTriangle = document.querySelector(`polygon.triangle[data-index="${triangleId}"]`);
          if (svgTriangle) {
            if (this.checked) {
              svgTriangle.classList.add('checked');
            } else {
              svgTriangle.classList.remove('checked');
            }
          }
        });
      });
      
      // Set up a MutationObserver to handle triangle item hover events
      if (!window.triangleHoverObserver) {
        window.triangleHoverObserver = new MutationObserver(function(mutations) {
          document.querySelectorAll('.triangle-item').forEach(item => {
            if (!item.hasHoverListeners) {
              const triangleId = item.getAttribute('data-triangle-id');
              
              item.addEventListener('mouseenter', function() {
                const svgTriangle = document.querySelector(`polygon.triangle[data-index="${triangleId}"]`);
                if (svgTriangle) {
                  svgTriangle.classList.add('hover-highlight');
                }
              });
              
              item.addEventListener('mouseleave', function() {
                const svgTriangle = document.querySelector(`polygon.triangle[data-index="${triangleId}"]`);
                if (svgTriangle) {
                  svgTriangle.classList.remove('hover-highlight');
                }
              });
              
              item.hasHoverListeners = true;
            }
          });
        });
        
        window.triangleHoverObserver.observe(selectedListEl, {
          childList: true,
          subtree: true
        });
      }
      
      // Immediately set up hover listeners for current items
      document.querySelectorAll('.triangle-item').forEach(item => {
        if (!item.hasHoverListeners) {
          const triangleId = item.getAttribute('data-triangle-id');
          
          item.addEventListener('mouseenter', function() {
            const svgTriangle = document.querySelector(`polygon.triangle[data-index="${triangleId}"]`);
            if (svgTriangle) {
              svgTriangle.classList.add('hover-highlight');
            }
          });
          
          item.addEventListener('mouseleave', function() {
            const svgTriangle = document.querySelector(`polygon.triangle[data-index="${triangleId}"]`);
            if (svgTriangle) {
              svgTriangle.classList.remove('hover-highlight');
            }
          });
          
          item.hasHoverListeners = true;
        }
      });
    }
  }
  
  // Function to update angle indicator for a triangle
  function updateAngleIndicator(triangleId, angle) {
    const poly = document.querySelector(`polygon.triangle[data-index="${triangleId}"]`);
    if (!poly) return;
    
    // Update data-angle attribute
    poly.setAttribute("data-angle", angle);
    
    // Update triangle fill color based on angle
    poly.classList.remove("angle-below-90", "angle-90", "angle-above-90");
    if (angle < 90) {
      poly.classList.add("angle-below-90");
    } else if (angle === 90) {
      poly.classList.add("angle-90");
    } else {
      poly.classList.add("angle-above-90");
    }
  }

  // Update triangle selection and angles based on current frame
  function updateTriangleSelection(){
    // Clear all selections first
    document.querySelectorAll('polygon.triangle').forEach(p=>{
      p.classList.remove("selected");
    });
    
    // Apply current frame's selections and angles
    const currentFrame = frames[currentFrameIndex];
    
    // First update all triangles to default angle if not specified in current frame
    document.querySelectorAll('polygon.triangle').forEach(p => {
      const index = p.getAttribute("data-index");
      const angle = currentFrame.angles[index] || DEFAULT_ANGLE;
      updateAngleIndicator(index, angle);
    });
    
    // Then apply selections
    currentFrame.selected.forEach(index => {
      const poly = document.querySelector(`polygon.triangle[data-index="${index}"]`);
      if (poly) poly.classList.add("selected");
    });
  }

  // Frame switching
  function switchToFrame(frameIndex) {
    if (frameIndex < 0 || frameIndex >= frames.length) return;
    
    currentFrameIndex = frameIndex;
    
    // Update active frame in UI
    document.querySelectorAll(".frame").forEach(frameEl => {
      frameEl.classList.remove("active");
    });
    document.querySelector(`.frame[data-frame="${frameIndex}"]`).classList.add("active");
    
    // Update triangle selections
    updateTriangleSelection();
    
    // Update other UI elements
    updateUI();
  }

  // Function to add a frame element to the UI
  function addFrameElement(frameIndex) {
    // Create frame UI element
    const frameEl = document.createElement("div");
    frameEl.classList.add("frame");
    frameEl.setAttribute("data-frame", frameIndex);
    frameEl.innerHTML = `<div class="frame-number">${frameIndex + 1}</div>`;
    frameEl.addEventListener("click", () => {
      if (!isPlaying) {
        switchToFrame(frameIndex);
      }
    });
    
    framesContainer.appendChild(frameEl);
  }
  
  // Add a new frame after the currently selected frame
  function addFrame() {
    const insertPosition = currentFrameIndex + 1; // Insert after current frame
    const previousSelections = new Set(frames[currentFrameIndex].selected);
    const previousAngles = frames[currentFrameIndex].angles;
    
    // Create new frame with copy of current selection and angles
    const newFrame = {
      id: insertPosition,
      selected: previousSelections,
      angles: {}
    };
    
    // Copy angles from the current frame for selected triangles
    previousSelections.forEach(triangleId => {
      if (previousAngles[triangleId]) {
        newFrame.angles[triangleId] = previousAngles[triangleId];
      }
    });
    
    // Insert the new frame after the current frame
    frames.splice(insertPosition, 0, newFrame);
    
    // Update IDs for all frames after the insertion point
    for (let i = insertPosition + 1; i < frames.length; i++) {
      frames[i].id = i;
    }
    
    // Clear and rebuild all frame elements to ensure correct IDs and event handlers
    framesContainer.innerHTML = '';
    frames.forEach((frame, index) => {
      addFrameElement(index);
    });
    
    // Switch to the newly added frame
    switchToFrame(insertPosition);
  }

  // Play animation
  function playAnimation() {
    if (isPlaying) return;
    if (frames.length <= 1) return; // Need at least 2 frames to animate
    
    isPlaying = true;
    document.getElementById("play-animation").classList.add("hidden");
    document.getElementById("stop-animation").classList.remove("hidden");
    
    let animationFrameIndex = 0;
    const speed = parseInt(animationSpeedSelect.value, 10);
    
    // Start animation loop
    animationInterval = setInterval(() => {
      switchToFrame(animationFrameIndex);
      animationFrameIndex = (animationFrameIndex + 1) % frames.length;
    }, speed);
  }

  // Stop animation
  function stopAnimation() {
    if (!isPlaying) return;
    
    clearInterval(animationInterval);
    isPlaying = false;
    document.getElementById("play-animation").classList.remove("hidden");
    document.getElementById("stop-animation").classList.add("hidden");
  }

  // Button event listeners
  saveBtn.addEventListener("click", () => {
    // Prepare the frames data for export
    const exportData = prepareFramesForExport();
    
    // Convert to JSON string with pretty formatting
    const jsonString = JSON.stringify(exportData, null, 2);
    
    // Create a blob with the JSON data
    const blob = new Blob([jsonString], { type: 'application/json' });
    
    // Get the filename from the input field
    const filenameInput = document.getElementById('save-filename');
    const filename = filenameInput.value.trim() || 'triangle_frames';
    
    // Create a download link
    const downloadLink = document.createElement('a');
    downloadLink.href = URL.createObjectURL(blob);
    downloadLink.download = `${filename}.json`;
    
    // Append to the body, click, and remove
    document.body.appendChild(downloadLink);
    downloadLink.click();
    document.body.removeChild(downloadLink);
  });
  
  // Play on Mirrors button
  const playOnMirrorsBtn = document.getElementById('play-on-mirrors');
  const stopMirrorsBtn = document.getElementById('stop-mirrors');
  const loopCheckbox = document.getElementById('loop-checkbox');
  
  playOnMirrorsBtn.addEventListener("click", async () => {
    // Disable the button during processing
    playOnMirrorsBtn.disabled = true;
    playOnMirrorsBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
    
    try {
      // Prepare the frames data for export
      const exportData = prepareFramesForExport();
      
      // Add loop parameter to the data
      const dataToSend = {
        frames: exportData,
        loop: loopCheckbox.checked
      };
      
      // Send the data to the server
      const response = await fetch('http://192.168.4.1/play_animation', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(dataToSend)
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        alert(`Error playing animation: ${result.message}`);
        console.error('Server error:', result);
      } else {
        // If it's a looping animation, show the stop button
        if (loopCheckbox.checked) {
          playOnMirrorsBtn.style.display = 'none';
          stopMirrorsBtn.style.display = 'inline-block';
        }
      }
    } catch (error) {
      alert(`Error: ${error.message}. Make sure the animation server is running.`);
      console.error('Error sending animation to server:', error);
    } finally {
      // Re-enable the button
      playOnMirrorsBtn.disabled = false;
      playOnMirrorsBtn.innerHTML = '<i class="fas fa-play-circle"></i>';
    }
  });
  
  // Stop Mirrors button
  stopMirrorsBtn.addEventListener("click", async () => {
    // Disable the button during processing
    stopMirrorsBtn.disabled = true;
    stopMirrorsBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
    
    try {
      // Call the kill_animation endpoint
      const response = await fetch('http://192.168.4.1/kill_animation');
      const result = await response.json();
      
      if (!response.ok) {
        alert(`Error stopping animation: ${result.message}`);
        console.error('Server error:', result);
      } else {
        console.log('Animation stopped:', result);
      }
    } catch (error) {
      alert(`Error: ${error.message}. Make sure the animation server is running.`);
      console.error('Error stopping animation:', error);
    } finally {
      // Switch back to play button
      stopMirrorsBtn.disabled = false;
      stopMirrorsBtn.innerHTML = '<i class="fas fa-stop"></i>';
      //stopMirrorsBtn.style.display = 'none';
      playOnMirrorsBtn.style.display = 'inline-block';
    }
  });
  
  // Import button and file input handling
  const importBtn = document.getElementById('import');
  const importFileInput = document.getElementById('import-file');
  
  importBtn.addEventListener("click", () => {
    importFileInput.click(); // Trigger the file input dialog
  });
  
  // Shutdown Raspberry Pi button event handler
  shutdownRaspberryBtn.addEventListener("click", async () => {
    // Ask for confirmation before shutting down
    const confirmShutdown = confirm("Are you sure you want to shut down the SunMirror? This will power off the device.");
    
    if (!confirmShutdown) return;
    
    // Disable the button during processing
    shutdownRaspberryBtn.disabled = true;
    
    try {
      // Send shutdown command to the server
      const response = await fetch('http://192.168.4.1/shutdown', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          confirmation: 'CONFIRM_SHUTDOWN'
        })
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        alert(`Error shutting down: ${result.message}`);
        console.error('Server error:', result);
      } else {
        alert("Shutdown command sent successfully. The Raspberry Pi will power off shortly.");
      }
    } catch (error) {
      alert(`Error: ${error.message}. Make sure the server is running.`);
      console.error('Error sending shutdown command:', error);
    } finally {
      // Re-enable the button
      shutdownRaspberryBtn.disabled = false;
    }
  });
  
  importFileInput.addEventListener("change", async (event) => {
    const file = event.target.files[0];
    if (!file) return;
    
    // Extract the filename without extension to use for the save filename
    const fileName = file.name.replace(/\.json$/, '');
    
    try {
      // Read the selected file
      const text = await file.text();
      const importedData = JSON.parse(text);
      
      // Validate the imported data
      if (!Array.isArray(importedData)) {
        throw new Error("Invalid format: Expected an array of frames");
      }
      
      // Clear existing frames
      frames.length = 0; // Empty the array without reassigning
      framesContainer.innerHTML = '';
      
      // Process each imported frame
      importedData.forEach(frameData => {
        // Create a new frame with the imported data
        const newFrame = {
          selected: new Set(),
          angles: {}
        };
        
        // If the imported frame has angles data, use it
        if (frameData.angles) {
          newFrame.angles = frameData.angles;
        }
        
        // Select triangles where angle is not 90 degrees (DEFAULT_ANGLE)
        if (frameData.angles) {
          Object.entries(frameData.angles).forEach(([index, angle]) => {
            if (angle !== DEFAULT_ANGLE) {
              newFrame.selected.add(index);
            }
          });
        }
        
        frames.push(newFrame);
        addFrameElement(frames.length - 1);
      });
      
      // Reset to the first frame
      currentFrameIndex = 0;
      updateFrameDisplay();
      
      // Update the selected count display
      const currentFrame = frames[currentFrameIndex];
      selectedCountEl.textContent = currentFrame.selected.size;
      
      // Update the filename input to match the imported file's name
      document.getElementById('save-filename').value = fileName;
      
      alert(`Successfully imported ${frames.length} frames from ${file.name}`);
    } catch (error) {
      alert(`Error importing file: ${error.message}`);
      console.error('Import error:', error);
    }
    
    // Reset the file input
    importFileInput.value = '';
  });
  
  selectAllBtn.addEventListener("click", ()=>{
    if (isPlaying) return; // Don't allow changes while playing
    
    const currentFrame = frames[currentFrameIndex];
    document.querySelectorAll("polygon.triangle").forEach(p=>{
      const index = p.getAttribute("data-index");
      currentFrame.selected.add(index);
      p.classList.add("selected");
    });
    updateUI();
  });
  
  clearBtn.addEventListener("click", ()=>{
    if (isPlaying) return; // Don't allow changes while playing
    
    const currentFrame = frames[currentFrameIndex];
    
    // Clear selection
    currentFrame.selected.clear();
    document.querySelectorAll("polygon.triangle.selected").forEach(p=>{
      p.classList.remove("selected");
    });
    
    // Reset all triangle angles to 90 degrees
    const DEFAULT_ANGLE = 90;
    for (let i = 1; i <= triangles.length; i++) {
      currentFrame.angles[i] = DEFAULT_ANGLE;
      updateAngleIndicator(i, DEFAULT_ANGLE);
    }
    
    updateUI();
  });
  
  // Set up angle buttons
  const angle20Btn = document.getElementById("angle-20");
  const angle90Btn = document.getElementById("angle-90");
  const angle160Btn = document.getElementById("angle-160");
  
  // Helper function to update active state of angle buttons
  function updateAngleButtonsState(activeAngle) {
    const customAngle1 = parseInt(document.getElementById('custom-angle-1').value, 10);
    const customAngle2 = parseInt(document.getElementById('custom-angle-2').value, 10);
    
    angle20Btn.classList.toggle('active', activeAngle === customAngle1);
    angle90Btn.classList.toggle('active', activeAngle === 90);
    angle160Btn.classList.toggle('active', activeAngle === customAngle2);
  }
  
  // Set angle for selected triangles to custom angle 1
  angle20Btn.addEventListener("click", () => {
    if (isPlaying) return; // Don't allow changes while playing
    
    const currentFrame = frames[currentFrameIndex];
    const customAngleInput = document.getElementById('custom-angle-1');
    let angle = parseInt(customAngleInput.value, 10);
    
    // Validate angle is within allowed range
    if (isNaN(angle) || angle < MIN_ANGLE) {
      angle = MIN_ANGLE;
      customAngleInput.value = MIN_ANGLE;
    } else if (angle > MAX_ANGLE) {
      angle = MAX_ANGLE;
      customAngleInput.value = MAX_ANGLE;
    }
    
    // Apply angle only to selected triangles with checked checkboxes
    const checkedTriangles = getCheckedTriangles();
    currentFrame.selected.forEach(index => {
      if (checkedTriangles.has(index)) {
        currentFrame.angles[index] = angle;
        updateAngleIndicator(index, angle);
      }
    });
    
    updateAngleButtonsState(angle);
    updateUI();
  });
  
  // Helper function to get triangles with checked checkboxes
  function getCheckedTriangles() {
    const checkedTriangles = new Set();
    document.querySelectorAll('.triangle-checkbox:checked').forEach(checkbox => {
      checkedTriangles.add(checkbox.getAttribute('data-triangle-id'));
    });
    return checkedTriangles;
  }
  
  // Group checkbox functionality
  const groupCheckbox = document.getElementById('group-checkbox');
  groupCheckbox.addEventListener('change', function() {
    const isChecked = this.checked;
    
    // Update all individual triangle checkboxes
    document.querySelectorAll('.triangle-checkbox').forEach(checkbox => {
      checkbox.checked = isChecked;
      
      // Update the checkbox state in our storage
      const triangleId = checkbox.getAttribute('data-triangle-id');
      if (triangleId) {
        checkboxStates[triangleId] = isChecked;
        
        // Update triangle color in the hexagon
        const svgTriangle = document.querySelector(`polygon.triangle[data-index="${triangleId}"]`);
        if (svgTriangle) {
          if (isChecked) {
            svgTriangle.classList.add('checked');
          } else {
            svgTriangle.classList.remove('checked');
          }
        }
      }
    });
  });
  
  // Set angle for selected triangles to 90°
  angle90Btn.addEventListener("click", () => {
    if (isPlaying) return; // Don't allow changes while playing
    
    const currentFrame = frames[currentFrameIndex];
    const angle = 90;
    
    // Apply angle only to selected triangles with checked checkboxes
    const checkedTriangles = getCheckedTriangles();
    currentFrame.selected.forEach(index => {
      if (checkedTriangles.has(index)) {
        currentFrame.angles[index] = angle;
        updateAngleIndicator(index, angle);
      }
    });
    
    updateAngleButtonsState(angle);
    updateUI();
  });
  
  // Set angle for selected triangles to custom angle 2
  angle160Btn.addEventListener("click", () => {
    if (isPlaying) return; // Don't allow changes while playing
    
    const currentFrame = frames[currentFrameIndex];
    const customAngleInput = document.getElementById('custom-angle-2');
    let angle = parseInt(customAngleInput.value, 10);
    
    // Validate angle is within allowed range
    if (isNaN(angle) || angle < MIN_ANGLE) {
      angle = MIN_ANGLE;
      customAngleInput.value = MIN_ANGLE;
    } else if (angle > MAX_ANGLE) {
      angle = MAX_ANGLE;
      customAngleInput.value = MAX_ANGLE;
    }
    
    // Apply angle only to selected triangles with checked checkboxes
    const checkedTriangles = getCheckedTriangles();
    currentFrame.selected.forEach(index => {
      if (checkedTriangles.has(index)) {
        currentFrame.angles[index] = angle;
        updateAngleIndicator(index, angle);
      }
    });
    
    updateAngleButtonsState(angle);
    updateUI();
  });
  
  // Reset angles to default
  resetAnglesBtn.addEventListener("click", () => {
    if (isPlaying) return; // Don't allow changes while playing
    
    const currentFrame = frames[currentFrameIndex];
    const checkedTriangles = getCheckedTriangles();
    
    // Reset angles for selected triangles or all if none selected
    if (currentFrame.selected.size > 0) {
      // Reset only selected triangles with checked checkboxes
      currentFrame.selected.forEach(index => {
        if (checkedTriangles.has(index)) {
          delete currentFrame.angles[index];
          updateAngleIndicator(index, DEFAULT_ANGLE);
        }
      });
    } else {
      // Reset all triangles
      Object.keys(currentFrame.angles).forEach(index => {
        delete currentFrame.angles[index];
        updateAngleIndicator(index, DEFAULT_ANGLE);
      });
    }
    
    updateUI();
  });
  
  addFrameBtn.addEventListener("click", addFrame);
  
  // Delete the current frame
  deleteFrameBtn.addEventListener("click", () => {
    if (isPlaying) return; // Don't allow changes while playing
    if (frames.length <= 1) return;  
    // Remove the current frame from the array
    frames.splice(currentFrameIndex, 1);
    
    // Update frame IDs in the frames array
    frames.forEach((frame, index) => {
      frame.id = index;
    });
    
    // Clear the frames container and rebuild all frame elements
    framesContainer.innerHTML = '';
    
    // Recreate all frame elements with correct event handlers
    frames.forEach((frame, index) => {
      addFrameElement(index);
    });
    
    // Adjust current frame index if needed
    if (currentFrameIndex >= frames.length) {
      currentFrameIndex = frames.length - 1;
    }
    
    // Update the display and UI (including selected triangles list)
    updateFrameDisplay();
    updateUI();
  });
  playBtn.addEventListener("click", playAnimation);
  stopBtn.addEventListener("click", stopAnimation);

  // Initialize first frame in UI
  // Add click handler to the first frame
  document.querySelector('.frame[data-frame="0"]').addEventListener("click", () => {
    if (!isPlaying) {
      switchToFrame(0);
    }
  });
  
  updateUI();

  // Cursor feedback
  svg.addEventListener("mouseover", (e)=>{
    if (e.target.matches("polygon.triangle")){
      svg.style.cursor = isPlaying ? "default" : (isCtrlPressed ? "cell" : "pointer");
    }
  });
  svg.addEventListener("mouseout", (e)=>{
    svg.style.cursor = "default";
  });
  
  // Track Ctrl key state
  document.addEventListener("keydown", (e) => {
    if (e.key === "Control") {
      isCtrlPressed = true;
      // Update cursor if hovering over a triangle
      const hoveredTriangle = document.querySelector("polygon.triangle:hover");
      if (hoveredTriangle && !isPlaying) {
        svg.style.cursor = "cell";
      }
    }
  });
  
  document.addEventListener("keyup", (e) => {
    if (e.key === "Control") {
      isCtrlPressed = false;
      // Update cursor if hovering over a triangle
      const hoveredTriangle = document.querySelector("polygon.triangle:hover");
      if (hoveredTriangle && !isPlaying) {
        svg.style.cursor = "pointer";
      }
    }
  });
  
  // Reset Ctrl key state when window loses focus
  window.addEventListener("blur", () => {
    isCtrlPressed = false;
  });
  
  // Touch event handling for mobile devices
  let lastTouchedTriangle = null;
  let touchStartX = 0;
  let touchStartY = 0;
  let touchStartTime = 0;
  
  // Function to find a triangle element at specific coordinates
  function findTriangleAtPoint(x, y) {
    // Get all triangles
    const triangles = document.querySelectorAll('polygon.triangle');
    
    // Get SVG dimensions and position
    const svgRect = svg.getBoundingClientRect();
    const svgCenterX = svgRect.left + svgRect.width / 2;
    const svgCenterY = svgRect.top + svgRect.height / 2;
    
    // Calculate coordinates for 210 degree rotation
    // For a 210 degree rotation, we need to apply the appropriate transformation
    const angle = 210 * Math.PI / 180; // Convert 210 degrees to radians
    const dx = x - svgCenterX;
    const dy = y - svgCenterY;
    
    // Apply rotation transformation
    const rotatedX = svgCenterX + dx * Math.cos(angle) - dy * Math.sin(angle);
    const rotatedY = svgCenterY + dx * Math.sin(angle) + dy * Math.cos(angle);
    
    // Use the rotated coordinates
    const svgPoint = svg.createSVGPoint();
    svgPoint.x = rotatedX;
    svgPoint.y = rotatedY;
    
    // Get the inverse of the current transformation matrix
    // This will convert screen coordinates to SVG coordinates accounting for all transforms
    const matrix = svg.getScreenCTM();
    if (!matrix) return null; // Safety check
    
    const transformedPoint = svgPoint.matrixTransform(matrix.inverse());
    
    // Check each triangle individually
    for (const triangle of triangles) {
      // For each triangle, we need to consider its own transformation relative to the SVG
      // Get the triangle's points in SVG coordinate space
      const points = triangle.getAttribute('points').split(' ').map(p => {
        const [x, y] = p.split(',').map(parseFloat);
        return [x, y];
      });
      
      // Use the point-in-polygon algorithm with the transformed point
      if (pointInPoly(transformedPoint.x, transformedPoint.y, points)) {
        return triangle;
      }
    }
    
    return null;
  }
  
  // Handle touch start
  svg.addEventListener('touchstart', (e) => {
    // Prevent default to avoid scrolling while selecting triangles
    e.preventDefault();
    isTouchSelecting = true;
    
    // Get touch coordinates relative to the viewport
    const touch = e.touches[0];
    
    // Find triangle at touch point using the findTriangleAtPoint function
    // which already handles the SVG transformation
    const triangle = findTriangleAtPoint(touch.clientX, touch.clientY);
    lastTouchedTriangle = triangle;
    
    // Store the start position and time for detecting taps
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
    touchStartTime = Date.now();
    
    // Highlight the triangle in the sidebar if found
    if (triangle) {
      const index = triangle.getAttribute('data-index');
      const sidebarItem = document.querySelector(`.triangle-item .triangle-angle-btn[data-triangle-id="${index}"]`)?.closest('.triangle-item');
      if (sidebarItem) {
        sidebarItem.classList.add("hover-highlight");
      }
    }
  });
  
  // Handle touch move (similar to mouseover with Ctrl pressed)
  svg.addEventListener('touchmove', (e) => {
    if (!isTouchSelecting || isPlaying) return;
    
    // Prevent default to avoid scrolling while selecting triangles
    e.preventDefault();
    
    // Get touch coordinates relative to the viewport
    const touch = e.touches[0];
    
    // Find triangle at touch point using the findTriangleAtPoint function
    // which already handles the SVG transformation
    const triangle = findTriangleAtPoint(touch.clientX, touch.clientY);
    
    // If we found a triangle (even if it's the same as the last one)
    if (triangle) {
      const index = triangle.getAttribute('data-index');
      const currentFrame = frames[currentFrameIndex];
      
      // Remove highlight from previous triangle if different
      if (lastTouchedTriangle && lastTouchedTriangle !== triangle) {
        const prevIndex = lastTouchedTriangle.getAttribute('data-index');
        const prevSidebarItem = document.querySelector(`.triangle-item .triangle-angle-btn[data-triangle-id="${prevIndex}"]`)?.closest('.triangle-item');
        if (prevSidebarItem) {
          prevSidebarItem.classList.remove("hover-highlight");
        }
      }
      
      // Add highlight to new triangle
      const sidebarItem = document.querySelector(`.triangle-item .triangle-angle-btn[data-triangle-id="${index}"]`)?.closest('.triangle-item');
      if (sidebarItem) {
        sidebarItem.classList.add("hover-highlight");
      }
      
      // Always select the triangle and check its checkbox when touched
      // This ensures that even if the checkbox was manually unchecked, it gets checked again on hover
      currentFrame.selected.add(index);
      triangle.classList.add("selected");
      
      // Always make sure the checkbox is checked when selected via touch
      checkboxStates[index] = true;
      updateUI();
      
      // Update last touched triangle
      lastTouchedTriangle = triangle;
    }
  });
  
  // Handle touch end
  svg.addEventListener('touchend', (e) => {
    isTouchSelecting = false;
    
    // Check if this was a tap (quick touch without much movement)
    const touchEndTime = Date.now();
    const touchDuration = touchEndTime - touchStartTime;
    
    // Get the last touch position
    const touch = e.changedTouches[0];
    const touchEndX = touch.clientX;
    const touchEndY = touch.clientY;
    
    // Calculate distance moved
    const touchDistance = Math.sqrt(
      Math.pow(touchEndX - touchStartX, 2) + 
      Math.pow(touchEndY - touchStartY, 2)
    );
    
    // If this was a tap (short duration and minimal movement)
    if (touchDuration < 300 && touchDistance < 10) {
      // Toggle selection of the triangle that was tapped
      if (lastTouchedTriangle && !isPlaying) {
        const index = lastTouchedTriangle.getAttribute('data-index');
        const currentFrame = frames[currentFrameIndex];
        
        // Toggle selection
        if (currentFrame.selected.has(index)) {
          currentFrame.selected.delete(index);
          lastTouchedTriangle.classList.remove("selected");
          checkboxStates[index] = false;
        } else {
          currentFrame.selected.add(index);
          lastTouchedTriangle.classList.add("selected");
          checkboxStates[index] = true;
        }
        
        // Update UI to reflect changes
        updateUI();
      }
    }
    
    // Remove highlight from last touched triangle
    if (lastTouchedTriangle) {
      const index = lastTouchedTriangle.getAttribute('data-index');
      const sidebarItem = document.querySelector(`.triangle-item .triangle-angle-btn[data-triangle-id="${index}"]`)?.closest('.triangle-item');
      if (sidebarItem) {
        sidebarItem.classList.remove("hover-highlight");
      }
      lastTouchedTriangle = null;
    }
  });
  
  // Cancel touch selection if touch is canceled
  svg.addEventListener('touchcancel', (e) => {
    isTouchSelecting = false;
    
    // Remove highlight from last touched triangle
    if (lastTouchedTriangle) {
      const index = lastTouchedTriangle.getAttribute('data-index');
      const sidebarItem = document.querySelector(`.triangle-item .triangle-angle-btn[data-triangle-id="${index}"]`)?.closest('.triangle-item');
      if (sidebarItem) {
        sidebarItem.classList.remove("hover-highlight");
      }
      lastTouchedTriangle = null;
    }
  });
  
  // Add event listeners for custom angle inputs
  const customAngle1Input = document.getElementById('custom-angle-1');
  const customAngle2Input = document.getElementById('custom-angle-2');
  
  customAngle1Input.addEventListener('input', function() {
    let value = parseInt(this.value, 10);
    if (isNaN(value) || value < MIN_ANGLE) {
      value = MIN_ANGLE;
      this.value = MIN_ANGLE;
    } else if (value > MAX_ANGLE) {
      value = MAX_ANGLE;
      this.value = MAX_ANGLE;
    }
  });
  
  customAngle2Input.addEventListener('input', function() {
    let value = parseInt(this.value, 10);
    if (isNaN(value) || value < MIN_ANGLE) {
      value = MIN_ANGLE;
      this.value = MIN_ANGLE;
    } else if (value > MAX_ANGLE) {
      value = MAX_ANGLE;
      this.value = MAX_ANGLE;
    }
  });
})();
</script>
</body>
</html>
